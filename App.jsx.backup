import { useEffect, useLayoutEffect, useRef, useState, React } from "react";
import "./App.css";
import { list } from "./assets/list";


function App(props) {

  //let assistant = initializeAssistant(() => getStateForAssistant() );


  /*
  function dispatchAssistantAction(action){
    if (action) {
      switch (action.type) {
        case 'get_str':
          handleClick(action.note)
          break

        default:
          throw new Error();  
      }
    }
  }*/

  //let tmpCurrentQuestion = ""
  const masT = []

  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [shiffledAnswer, setShiffledAnswer] = useState(null);
  const [answerCount, setAnswerCount] = useState({ current: 0, failed: 0 });
  const [userAnswer, setUserAnswer] = useState([]);
  const [usedSentences, setUsedSentences] = useState([]);
  const [isCompleted, setIsCompleted] = useState(false);
  

  useEffect(() => {
    props.assistant.on("data",(event) => {
      const { action } = event
      if((action)&&((action.note!=userAnswer[userAnswer.length-1])||(userAnswer.length==0))){
        //console.log(tmpCurrentQuestion + "  4")
        dispatchAssistantAction(action)
        //console.log(tmpCurrentQuestion + "  5")
      }
    }); 
  },[userAnswer]);

  
  function dispatchAssistantAction(action){
    if (action) {
      
      switch (action.type) {
        
        case 'get_str':
          const tmp = localStorage.getItem('key').split(" ").map(e => similarity(action.note , e.toLowerCase()))
          const max = Math.max(...tmp)
          const maxIndex = tmp.indexOf(max)
          if(max > 0.7){
            handleClick(localStorage.getItem('key').split(" ")[maxIndex])
          }
          break
        case 'continue':
          setUsedSentences(usedSentences.pop());
          newQuestion();
          break

        case 'clear':
          console.log("привет")
          if (userAnswer.join(" ") === currentQuestion?.ru) {

            setUsedSentences([...usedSentences, currentQuestion]);
            setUserAnswer([]);
            newQuestion();
            console.log("привет1")
          } else if (userAnswer.length === currentQuestion?.ru.split(" ")?.length) {
            //Если не осталось слов, нечего больше выбирать.
            setUserAnswer([]);
            //tmpUserAnswer = []
            console.log("привет2")
          }
          break
        default:
          throw new Error();  
      }
    }
  }

  
  function similarity(s1, s2) {
    var longer = s1;
    var shorter = s2;
    if (s1.length < s2.length) {
      longer = s2;
      shorter = s1;
    }
    var longerLength = longer.length;
    if (longerLength == 0) {
      return 1.0;
    }
    return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
  }

  function editDistance(s1, s2) {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();
  
    var costs = new Array();
    for (var i = 0; i <= s1.length; i++) {
      var lastValue = i;
      for (var j = 0; j <= s2.length; j++) {
        if (i == 0)
          costs[j] = j;
        else {
          if (j > 0) {
            var newValue = costs[j - 1];
            if (s1.charAt(i - 1) != s2.charAt(j - 1))
              newValue = Math.min(Math.min(newValue, lastValue),
                costs[j]) + 1;
            costs[j - 1] = lastValue;
            lastValue = newValue;
          }
        }
      }
      if (i > 0)
        costs[s2.length] = lastValue;
    }
    return costs[s2.length];
  }

///тут формируется новый вопрос

  const newQuestion = () => {
    const newItemNumber = Math.floor(Math.random() * list.length);
    const newItem = list[newItemNumber];
    localStorage.setItem('key', newItem.ru);
    //если всего слов равно количеству правильных ответов
    if (list.length === answerCount.current) {
      //закончить игру
      setIsCompleted(true);
      return;
    }
    //проверка было ли использовано предложение
    if (
      usedSentences.find(
        (item) =>
          item.ru.toLowerCase().replaceAll(" ") ===
          newItem.ru.toLowerCase().replaceAll(" ")
      )
    ) 
    {
      //console.log(currentQuestion + " 1")
      return newQuestion();
    } else 
    {
      setUsedSentences([...usedSentences, newItem]);
      setCurrentQuestion(newItem);
      
    }
  };


  //тут перетасовываются 'части' ответа
  function shuffle() {
    const arr = currentQuestion.ru.split(" ");
    return arr ? arr.sort(() => Math.random() - 0.5) : [];
  }


  //тут клик на кнопку
  const handleClick = (item) => {
    setUserAnswer([...userAnswer, item]);
  };


  //тут установка вопроса при первой загрузке
  useEffect(() => {
    newQuestion();
  }, []);


  //тут перетасовка ответа при изменение вопроса
  useEffect(() => {
    //console.log(currentQuestion + " 6")
    if (currentQuestion) {
      setShiffledAnswer(shuffle());
      //setContButton(shiffledAnswer.length)
    }
  }, [currentQuestion]);

    //тут проверка ответа при добавлении нового слова

    useEffect(() => {
      //Если ответ пользователя и правильный ответ совпадают
      //console.log(userAnswer + "  Гей  "+ currentQuestion?.ru)
      if (userAnswer.join(" ") === currentQuestion?.ru) {

        setUsedSentences([...usedSentences, currentQuestion]);
        setAnswerCount({ ...answerCount, current: ++answerCount.current  });
        setUserAnswer([]);
        newQuestion();
      } else if (userAnswer.length === currentQuestion?.ru.split(" ")?.length) {
        //Если не осталось слов, нечего больше выбирать.
        setAnswerCount({ ...answerCount, failed: ++answerCount.failed  });
        setUserAnswer([]);
        //tmpUserAnswer = []
      }
    }, [userAnswer]);

    
  return (
    <div className="container">
      {isCompleted ? (
        <div className="end">congratulations!</div>
      ) : (
        <div className="wrapper">
          <div className="header">Learn English</div>
          <div className="question">Переведи: {currentQuestion?.en}</div>
          <div className="user_answer">
            <div className="user_answer_header">Ваш ответ:</div>
            <div className="user_answer_current">
              <span>{userAnswer?.join(" ")}</span>
            </div>
          </div>
          <div className="btn">
            <div className="btn_header">Выбери правильный порядок слов</div>
            <div className="btn_list">
              {shiffledAnswer?.map((item, index) => {
                if (!userAnswer.includes(item)) {
                  //это кнопки с ответами
                  return (
                    <button key={index} onClick={() => handleClick(item)}>
                      {item}
                    </button>
                  );
                }
              })}
            </div>
          </div>
          <div className="answer_count">
            <span>
              правильно: <b>{answerCount.current}</b>
            </span>
            <span>
              неправильно: <b>{answerCount.failed}</b>
            </span>
          </div>
          <div className="btn_skip">
            <button
              onClick={() => {
                //это пропуск
                setUsedSentences(usedSentences.pop());
                newQuestion();
              }}
            >
              Пропустить
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
